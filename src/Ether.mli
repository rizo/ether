(*---------------------------------------------------------------------------
   Copyright (c) 2017 Rizo Isrof. All rights reserved.
   Distributed under the ISC license, see terms in the LICENSE file.
  ---------------------------------------------------------------------------*)

(** {e Ether} is an alternative {e Pervasives} module for OCaml rethought from
    the ground up for a consistent, safe and friendly development experience.

    {e Pervasives} is open by default in all OCaml modules. The great thing
    about it is that it's concise and tested by time. The bad thing about it is
    that it's too minimalistic and is starting to show its age.

    Making changes to such a central dependency as the standard library is
    extremely difficult because of the backward-compatibility requirements.

    This library attempts to give a fresh view using modern approach.

    The main goal of {e Ether} is to provide a sensible set of defaults for new
    OCaml projects.

    Historical cruft that canâ€™t be removed due to backward-compatibility
    requirements.

    What would a modern OCaml standard library look like if we could design it
    from scratch?

    Ether is not compatible with the standard [Pervasives].

    {!Tutorial}

    {3:view_functions View Functions}

    View functions are {i views} into data types. In theory they are equivalent
    to patten-matching but in practice can result in more composable and
    efficient code.


    {3:content Content}

    {ol
    {- {{: #equality} Equality}}
    {- {{: #ordering} Ordering}}
    {- {{: #formatting_and_pretty_printing} Formatting and Pretty-printing}}
    {- {{: #interfaces} Common Interfaces}}
    {- {{: #interfaces} Exceptions}}
    {- {{: #data} Standard Data Types}}
    {- {{: #fun} Function Type and Operations}}
    {- {{: #option} Optional and Result Values}}
    {- {{: #public_exports} Public Exports}}}
*)

(** {1:equality Equality}

    This section defines the interfaces and operations for equality comparisons
    which are equivalence relations. This means that the equality must be:
    reflexive, symmetric and transitive.

    Polymorphic functions for both structural ({{: #val-(=)} [(=)]}, {{:
    #val-(<>)} [(<>)]}, {{: #val-equal} [equal]}) and physical ({{: #val-is}
    [is]}) equality are provided.

    The data types defined in {e Ether} do not rely on polymorphic functions
    because they are usually slower than the type-specific implementation.

    User-defined types can implement the {!Equatable}, {!Equatable1} or
    {!Equatable2} interfaces (based on to the arity of the main type) to
    included a custom equality comparison function. Alternatively the equality
    function can be automatically generated by the [deriving] syntax extension
    (consult the {{:
    https://github.com/ocaml-ppx/ppx_deriving#plugins-eq-and-ord} ppx_deriving}
    project for more details).  *)

val ( = ) : 'a -> 'a -> bool
(** [a = b] tests for structural equality of [a] and [b]. Mutable
    structures (e.g. references and arrays) are equal if and only if their
    current contents are structurally equal, even if the two mutable objects
    are not the same physical object.

    @raise Invalid_argument if function values are compared for equality.

    {b Warning:} Equality between cyclic data structures may not terminate.

    {b See also: } {{: #val-equal} [equal]}, {{: #val-is} [is]} *)

val ( <> ) : 'a -> 'a -> bool
(** [a <> b] is [not (a = b)], {e i.e.}, the negation of {!(=)}. *)

val equal : 'a -> 'a -> bool
(** [equal a b] is equivalent to [a = b]. *)

val is : 'a -> 'a -> bool
(** [is a b] tests for physical equality of [a] and [b].

    On mutable types such as references, arrays, byte sequences, records with
    mutable fields and objects with mutable instance variables, [is a b] is
    true if and only if physical modification of [a] also affects [b].

    On non-mutable types, the behavior of [is] is implementation-dependent;
    however, it is guaranteed that [is a b] implies [a = b].

    To check if two values are physically distinct use [not (is a b)]. *)


(** Nullary signature for equality comparisons which are equivalence relations.

    [Equatable.Base] is the minimal implementation of the [Equatable] instance.
    Some examples of nullary equatable types, i.e., types without parameters
    include: [Int.t], [Float.t], [Char.t], etc. *)
module type Equatable = sig
  type t
  (** The type of the equatable monomorphic values, i.e., non-polymorphic
      nullary values, such as [int], [char], etc. *)

  val equal : t -> t -> bool

  val ( = ) : t -> t -> bool

  val ( <> ) : t -> t -> bool
end


(** Structure defining the [Base] implementation for nullary [Equatable]
    signature and a functor to build the extended signature. *)
module Equatable : sig
  module type Base = sig
    type t

    val equal : t -> t -> bool
  end

  module Make(B : Base) : (Equatable with type t := B.t)
  (** Functor building an instance of {!Equatable} given a {!Equatable.Base}
      implementation. *)
end


(** Unary signature for equality comparisons which are equivalence relations.

    The extended version of [Equatable] for polymorphic types is not possible
    since the included infix functions are only useful with two arguments and
    [Equatable1] would require an extra [equal] argument for each type
    parameter.

    If desired, the generic infix functions can be used with the default
    {!equal} implementation. *)
module type Equatable1 = sig
  type 'a t

  val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
end


(** Binary signature for equality comparisons which are equivalence relations. *)
module type Equatable2 = sig
  type ('a, 'b) t

  val equal :
    ('a -> 'a -> bool) ->
    ('b -> 'b -> bool) -> ('a, 'b) t -> ('a, 'b) t -> bool
end


(** {1:ordering Ordering} *)

type order = int
(** Defines the relative ordering of two values. The relations are less than
    (order < 0), equal to (order = 0), and greater than (order > 0). *)

val compare : 'a -> 'a -> order
(** [compare a b] returns [0] if [a] is equal to [b], [-1] if [a] is less than
    [b], and [1] if [a] is greater than [b].

    The ordering implemented by [compare] is compatible with the comparison
    predicates [=], [<] and [>] defined above, with one difference on the
    treatment of the float value {!nan}. Namely, the comparison predicates
    treat [nan] as different from any other float value, including itself;
    while [compare] treats [nan] as equal to itself and less than any other
    float value. This treatment of [nan] ensures that [compare] defines a
    total ordering relation.

    [compare] applied to functional values may raise [Invalid_argument].
    [compare] applied to cyclic structures may not terminate. *)

val ( <  ) : 'a -> 'a -> bool
val ( >  ) : 'a -> 'a -> bool
val ( <= ) : 'a -> 'a -> bool
val ( >= ) : 'a -> 'a -> bool
(** Structural ordering functions.

    These functions coincide with the usual orderings over integers,
    characters, strings, byte sequences and floating-point numbers, and extend
    them to a total ordering over all types.  The ordering is compatible with
    {!(==)}. As in the case of {!(==)}, mutable structures are compared by
    contents.

    Comparison between functional values raises [Invalid_argument].  Comparison
    between cyclic structures may not terminate. *)

val min : 'a -> 'a -> 'a
(** [min a b] returns the smaller of the two arguments.

    The result is unspecified if one of the arguments contains
    the float value [nan].

{[
assert (min 2 5 = 2);
assert (min [1; 2; 3] [2; 3; 4] = [1; 2; 3])
]} *)

val max : 'a -> 'a -> 'a
(** [max a b] returns the greater of the two arguments.

    The result is unspecified if one of the arguments contains
    the float value [nan].

{[
assert (max 2 5 = 5);
assert (max [1; 2; 3] [2; 3; 4] = [2; 3; 4])
]} *)

(** Nullary comparable signature for types that form a total order.

    [Comparable.Base] is the minimal implementation of the [Comparable]
    instance. Some examples of nullary comparable types, i.e., types with one
    parameter, include: {!Option.t}, {!List.t}, {!Array.t}, etc. *)
module type Comparable = sig
  type t

  include Equatable with type t := t

  val compare : t -> t -> order
  val ( <  ) : t -> t -> bool
  val ( >  ) : t -> t -> bool
  val ( <= ) : t -> t -> bool
  val ( >= ) : t -> t -> bool
  val min : t -> t -> t
  val max : t -> t -> t
end


(** Structure defining the [Base] implementation for nullary [Comparable]
    signature and a functor to build the extended signature. *)
module Comparable : sig
  val less    : order
  val equal   : order
  val greater : order

  module type Base = sig
    type t

    val compare : t -> t -> order
  end

  module Make(B : Base) : (Comparable with type t := B.t)
  (** Functor building an instance of {!Comparable} given a {!Comparable.Base}
      implementation. *)
end


(** Unary comparable signature for types that form a total order.

    The infix functions for the polymorphic versions of [Comparable] are not
    included since it would requires extra [compare] arguments for each type
    parameter and the infix functions are only useful with two arguments.

    If desired, the generic infix functions can be used with the default
    {!compare} implementation. *)
module type Comparable1 = sig
  type 'a t

  val compare : ('a -> 'a -> order) -> 'a t -> 'a t -> order

  val min : ('a -> 'a -> order) -> 'a t -> 'a t -> 'a t

  val max : ('a -> 'a -> order) -> 'a t -> 'a t -> 'a t
end


(** Structure defining the [Base] implementation for unary [Comparable1]
    signature and a functor to build the extended signature. *)
module Comparable1 : sig
  module type Base = sig
    type 'a t

    val compare : ('a -> 'a -> order) -> 'a t -> 'a t -> order
  end

  module Make(B : Base) : (Comparable1 with type 'a t := 'a B.t)
  (** Functor building an instance of {!Comparable1} given a
      {!Comparable1.Base} implementation. *)
end


(** Binary comparable signature for types that form a total order. *)
module type Comparable2 = sig
  type ('a, 'b) t

  val compare :
    ('a -> 'a -> order) -> ('b -> 'b -> order) ->
    ('a, 'b) t -> ('a, 'b) t -> order

  val min :
    ('a -> 'a -> order) -> ('b -> 'b -> order) ->
    ('a, 'b) t -> ('a, 'b) t -> ('a, 'b) t

  val max :
    ('a -> 'a -> order) -> ('b -> 'b -> order) ->
    ('a, 'b) t -> ('a, 'b) t -> ('a, 'b) t
end


(** Structure defining the [Base] implementation for the binary [Comparable2]
    signature and a functor to build the extended signature. *)
module Comparable2 : sig
  module type Base = sig
    type ('a, 'b) t

    val compare :
      ('a -> 'a -> order) -> ('b -> 'b -> order) ->
      ('a, 'b) t -> ('a, 'b) t -> order
  end

  module Make(B : Base) : (Comparable2 with type ('a, 'b) t := ('a, 'b) B.t)
  (** Functor building an instance of {!Comparable2} given a
      {!Comparable2.Base} implementation. *)
end


(** {1:formatting_and_pretty_printing Formatting and Pretty-printing}

    This section contains the primitives for formatting and pretty-printing. *)

type 'a printer = Format.formatter -> 'a -> unit
(** The type for pretty-printers of values of type ['a]. *)

val print : ?output: out_channel -> ?break:string -> string -> unit
(** [print ?output ?break s] outputs [s] on the [output] channel followed by
    [break].

    @param output (default = [stdout]) â€“ The output channel to write on.
    @param break (default = ["\n"]) â€“ String to be appended at the end of [s].

{[
print "hello";
print "hello, world" ~break:"!!!\n";
print (format "hello, %s!" "world");
print ~output:stderr "hello";
]} *)

val format : ('a, Format.formatter, unit, string) format4 -> 'a
(** [format fmt (arg1 ... argN)] formats the arguments [arg1] to [arnN]
    according to the format string [fmt] and returns the result as a string.

    The format string is a character string which contains two types of
    objects: plain characters, which are simply copied to the output channel,
    and conversion specifications, each of which causes conversion and printing
    of arguments. For more details see the {!Format} module.

    It is an alias for [Format.asprintf].

{[
assert (format "x = %d" 42 = "x = 42");
assert (format "Hello, %s!" world = "Hello, world!");
]} *)

(** Signature for the monomorphic types that can be printed.

    [Printable.Base] is the minimal implementation of the [Printable] instance.
    Some examples of nullary printable types, i.e., types without parameters
    include: [Int.t], [Float.t], [Char.t], [Unit.t], etc. *)
module type Printable = sig
  type t
  (** The type of the printable monomorphic values, i.e., non-polymorphic
      nullary values, such as [int], [string], etc. *)

  val pp : t printer
  (** [pp] is the pretty-printer for the type {!t}. *)

  val show : t -> string
  (** [show self] converts [self] to a string representation using the {!pp}
      pretty-printer. *)

  val print : t -> unit
  (** [print self] writes [self] to the standard output using the {!pp}
      pretty-printer. *)
end


(** Structure defining the [Base] implementation for nullary [Printable]
    signature and a functor to build the extended signature. *)
module Printable : sig
  module type Base = sig
    type t
    (** The type of the printable monomorphic values, i.e., non-polymorphic
        nullary values, such as [int], [string], etc. *)

    val pp : t printer
    (** [pp] is the pretty-printer for the type {!t}. *)
  end

  module Make(B : Base) : (Printable with type t := B.t)
  (** Functor building an instance of {!Printable} given a {!Printable.Base}
      implementation. *)
end


(** Signature for the unary types that can be printed.

    [Printable1.Base] is the minimal implementation of the [Printable]
    instance. Some examples of unary printable types, i.e., types with one
    parameter, include: {!Option.t}, {!List.t}, {!Array.t}, etc. *)
module type Printable1 = sig
  type 'a t
  (** The type of the printable polymorphic values of arity one, i.e., values
      with one type parameter, such as ['a list], ['a option], etc. *)

  val pp : 'a printer -> 'a t printer
  (** [pp pp_a] is the pretty-printer for the unary type ['a t]. [pp_a] is the
      pretty-printer for the wrapped type ['a]. *)

  val show : 'a printer -> 'a t -> string
  (** [show pp_a self] converts unary {!'a t} to a string representation using
      {!pp_a} for the wrapped type. *)

  val print : 'a printer -> 'a t -> unit
  (** [print pp_a self] writes [self] to the standard output using [pp_a]
      pretty-printer for the wrapped type and {!Printable1.pp} for [self]. *)
end


(** Structure defining the [Base] implementation for unary [Printable1]
    signature and a functor to build the extended signature. *)
module Printable1 : sig
  module type Base = sig
    type 'a t
    (** The type of the printable polymorphic values of arity one, i.e., values
        with one type parameter, such as ['a list], ['a option], etc. *)

    val pp : 'a printer -> Format.formatter -> 'a t -> unit
    (** [pp] is the pretty-printer for the type {!t}. *)
  end

  module Make(B : Base) : (Printable1 with type 'a t := 'a B.t)
  (** Functor building an instance of {!Printable1} given a {!Printable1.Base}
      implementation. *)
end


(** Signature for the binary types that can be printed.

    [Printable2.Base] is the minimal implementation of the [Printable2]
    instances. Some examples of binary printable types, i.e., types with two
    parameters, include: {!('a, 'e) Result.t} and {!('a, 'b) Either.t}. *)
module type Printable2 = sig
  type ('a, 'b) t
  (** The type of the printable polymorphic values of arity two, i.e., values
      with two type parameters, such as [('a, 'e) Result.t] and [('a, 'b)
      Either.t]. *)

  val pp : 'a printer -> 'b printer -> ('a, 'b) t printer
  (** [pp pp_a pp_b] is the pretty-printer for the binary type [('a, 'b) t].
      [pp_a] and [pp_b] are the pretty-printers for the wrapped types ['a] and
      ['b]. *)

  val show : 'a printer -> 'b printer -> ('a, 'b) t -> string
  (** [show pp_a pp_b self] converts binary [('a, 'b) t] to a string
      representation using [pp_a] and [pp_b] for the wrapped types ['a] and
      ['b]. *)

  val print : 'a printer -> 'b printer -> ('a, 'b) t -> unit
  (** [print pp_a pp_b self] writes [self] to the standard output using [pp_a]
      and [pp_b] pretty-printers for the wrapped types and {!Printable1.pp} for
      [self]. *)
end


(** Structure defining the [Base] implementation for binary [Printable2]
    signature and a functor to build the extended signature. *)
module Printable2 : sig
  module type Base = sig
    type ('a, 'b) t
    (** The type of the printable polymorphic values of arity two, i.e., values
        with two type parameters, such as [('a, 'e) Result.t] and [('a, 'b)
        Either.t]. *)

    val pp : 'a printer -> 'b printer -> ('a, 'b) t printer
    (** [pp pp_a pp_b] is the pretty-printer for the binary type [('a, 'b) t].
        [pp_a] and [pp_b] are the pretty-printers for the wrapped types ['a] and
        ['b]. *)
  end

  module Make(B : Base) : (Printable2 with type ('a, 'b) t := ('a, 'b) B.t)
  (** Functor building an instance of {!Printable2} given a {!Printable2.Base}
      implementation. *)
end


(** {1:interfaces Common Interfaces} *)

(* Signature for nullary hashable types. *)
module type Hashable = sig
  type t

  val hash : t -> int
end


(* Signature for unary hashable types. *)
module type Hashable1 = sig
  type 'a t

  val hash : ('a -> int) -> 'a t -> int
end


(* Signature for binary hashable types. *)
module type Hashable2 = sig
  type ('a, 'b) t

  val hash : ('a -> int) -> ('b -> int) -> ('a, 'b) t -> int
end


(* Bounded is used to name the upper and lower limits of a type. *)
module type Bounded = sig
  type t

  val min_value : t
  val max_value : t
end


(** Signature for nullary types with a default value. *)
module type Default = sig
  type t

  val default : t
end

(** Signature for unary types with a default value. *)
module type Default1 = sig
  type 'a t

  val default : 'a t
end


(** Enum defines operations on sequentially ordered types. *)
module type Enumerable = sig
  type t

  val predecessor : t -> t
  (** [pred self] is the predecessor of [self].

      @raise No_value if [self] has no predecessor. *)

  val successor : t -> t
  (** [succ self] is the successor of [self].

      @raise No_value if [self] has no successor. *)
end


(** Signature for the nullary types that can be parsed. *)
module type Parsable = sig
  type t

  val parse : string -> t option
end


(** Signature for the unary types that can be parsed. *)
module type Parsable1 = sig
  type 'a t

  val parse : (string -> 'a) -> string -> 'a t option
end


(** Signature for the binary types that can be parsed. *)
module type Parsable2 = sig
  type ('a, 'b) t

  val parse : (string -> 'a) -> (string -> 'b) -> string -> ('a, 'b) t option
end


(** Basic numeric interface. *)
module type Numeric = sig
  type t

  val ( + ) : t -> t -> t
  val ( - ) : t -> t -> t
  val ( * ) : t -> t -> t
  val (~- ) : t -> t
  val (~+ ) : t -> t
  val abs : t -> t
  val signum : t -> t
  val of_int : int -> t
end


(** {1:exn Exceptions} *)

val raise : ?trace: bool -> exn -> 'a
(** [raise ?trace exn] raises the exception [exn]. If [trace] is [false] no
    backtrace will be recorded, resulting in faster execution.

{[
let check_list l =
  if List.is_empty l then
    raise Not_found ~trace:false
  else
  print "list is not empty" in
assert
  (try
    check_list [];
    false
  with Not_found -> true)
]} *)

val raises : ?only: exn -> (unit -> 'a) -> bool
(** [raises ?only f] is [true] if the exception [exn] is raised while calling
    [f], [false] otherwise. If no [exn] is given, will return [true] on any
    exception.

{[
assert (raises (fun () -> fail "yes"));
assert (raises (fun () -> Option.force None) ~only:No_value);
assert (not (raises (fun () -> "no")))
]} *)

val fail : string -> 'a
(** [fail msg] raises the [Failure] exception with given [msg]. Should be used
    for generic failures with a simple message.

{[
if List.length a = 0 then
  fail "empty list"
else
  print "non-empty"
]} *)

exception Undefined
(** An exception for undefined or not implemented code branches. *)

val undefined : unit -> 'a
(** [undefined ()] raises the [Undefined] exception.

{[
let x = 42 in
match x with
| x when x = 0 -> " "
| x when x > 0 -> "+"
| x when x < 0 -> "-"
| _            -> undefined ()
]} *)


(** {1:data Standard Data Types} *)

(** Unit type and operations. *)
module Unit : sig
  type t = unit

  (** {2:implemented_instances Implemented instances} *)

  include Bounded    with type t := t
  include Comparable with type t := t
  include Default    with type t := t
  include Equatable  with type t := t
  include Hashable   with type t := t
  include Parsable   with type t := t
  include Printable  with type t := t
end


(** Boolean type and operations. *)
module Bool : sig
  type t = bool
  (** Standard boolean type. *)

  val not : t -> t
  (** [not a] is the boolean negation of [a]. *)

  val ( && ) : t -> t -> t
  (** [a && b] is the boolean 'and' of [a] and [b]. Evaluation is sequential,
      left-to-right, [a] is evaluated first, and if it returns [false], [b] is
      not evaluated at all. *)

  val ( || ) : t -> t -> t
  (** [a || b] is the boolean 'or' of [a] and [b]. Evaluation is sequential,
      left-to-right, [a] is evaluated first, and if it returns [true], [b] is
      not evaluated at all. *)

  val of_int : int -> bool
  val to_int : bool -> int

  val to_option : 'a -> t -> 'a option
  (** [to_option x self] is an optional value containing [x] if [self] is
      [true] and [None] otherwise.

{[
assert (Bool.to_option 42 false == None);
assert (Bool.to_option 42 true  == Some 42);
]} *)

  (** {6 Implemented instances} *)
  include Bounded    with type t := t
  include Comparable with type t := t
  include Default    with type t := t
  include Enumerable with type t := t
  include Equatable  with type t := t
  include Hashable   with type t := t
  include Parsable   with type t := t
  include Printable  with type t := t
end


(** Integer type and arithmetic operations. *)
module Int : sig
  type t = int
  (** Standard integer type. *)

  val ( / ) : t -> t -> t
  (* Integer devision. *)

  val ( mod ) : t -> t -> t

  (** {6:conv Conversion } *)

  val to_string : t -> string
  (** [to_string x] is a string representation of the integer [x]. *)

  val of_float : float -> int
  (** [of_float x] is an integer representation of the float value [x]. *)

  val of_char : char -> int
  (** [of_char x] is an integer representation of the char value [x].

      See [Char.try_of_int] *)

  module Unsafe : sig
    val of_string : string -> int
    (** [of_string str] is an integer created by parsing the string [str].

        @raise Failure if the string does not represent a valid integer. *)
  end

  (** {6 Implemented instances} *)
  include Bounded    with type t := t
  include Comparable with type t := t
  include Default    with type t := t
  include Enumerable with type t := t
  include Equatable  with type t := t
  include Hashable   with type t := t
  include Numeric    with type t := t
  include Parsable   with type t := t
  include Printable  with type t := t
end


(** Float type and arithmetic operations. *)
module Float : sig
  type t = float

  val ( / ) : t -> t -> t

  val ( mod ) : t -> t -> t

  val infinity : float
  (** Positive infinity. *)

  val neg_infinity : float
  (** Negative infinity. *)

  val nan : float
  (** A special floating-point value denoting the result of an undefined
      operation such as [0.0 /. 0.0]. Stands for 'not a number'. Any
      floating-point operation with [nan] as argument returns [nan] as result.
      As for floating-point comparisons, [=], [<], [<=], [>] and [>=] return
      [false] and [<>] returns [true] if one or both of their arguments is [nan]. *)

  val epsilon : float
  (** The difference between [1.0] and the smallest exactly representable
      floating-point number greater than [1.0]. *)

  val round : float -> float
  (** [round f] rounds the float value to the nearest integer float. *)

  val exp : float -> float
  (** Exponential. *)

  val frexp : float -> float * int
  (** [frexp f] returns the pair of the significant and the exponent of [f]. When
      [f] is zero, the significant [x] and the exponent [n] of [f] are equal to
      zero.  When [f] is non-zero, they are defined by [f = x *. 2 ** n] and [0.5
      <= x < 1.0]. *)

  val ldexp : float -> int -> float
  (** [ldexp x n] returns [x *. 2 ** n]. *)

  val modf : float -> float * float
  (** [modf f] returns the pair of the fractional and integral part of [f]. *)

  type fpclass = Pervasives.fpclass
  (** The five classes of floating-point numbers, as determined by
      the {!Pervasives.classify_float} function. *)

  val classify : float -> fpclass
  (** Return the class of the given floating-point number:
      normal, subnormal, zero, infinite, or not a number. *)

  (** {2:conv Conversion } *)

  (* XXX: why is this unused? *)
  (* val of_int : int -> float *)
  (** Convert an integer to floating-point. *)

  val to_int : float -> int
  (** Truncate the given floating-point number to an integer. The result is
      unspecified if the argument is [nan] or falls outside the range of
      representable integers. *)

  val to_string : float -> string

  val try_of_string : string -> float option
  (** [try_of_string str] is a float value converted from the string [str] or
      [None] if the string does not represent a valid float. *)

  module Unsafe : sig
    val of_string : string -> float
    (** [of_string str] is a float created by parsing the string [str].

        @raise Failure if the string does not represent a valid integer. *)
  end

  (** {6 Implemented instances} *)
  include Bounded    with type t := t
  include Comparable with type t := t
  include Default    with type t := t
  include Equatable  with type t := t
  include Hashable   with type t := t
  include Numeric    with type t := t
  include Parsable   with type t := t
  include Printable  with type t := t
end


(** Char type and operations. *)
module Char : sig
  type t = char
  (** The type for bytes. *)

  (** {2:conversions Conversions} *)

  val try_of_int : int -> char option
  (** [try_of_int b] is a byte from [b]. [None] is returned if [b] is not in
      the range \[[0x00];[0xFF]\]. *)

  val to_int : char -> int
  (** [to_int b] is the byte [b] as an integer. *)


  module Unsafe : sig
    val of_int : int -> char
    (** [of_int b] is a byte from [b].

        {e See also:} [Char.of_int]
        @raise Failure if the byte [b] does not represent a valid char. *)
  end


  (** {2 Implemented instances} *)

  include Bounded    with type t := t
  include Comparable with type t := t
  include Default    with type t := t
  include Enumerable with type t := t
  include Equatable  with type t := t
  include Hashable   with type t := t
  include Parsable   with type t := t
  include Printable  with type t := t
end


(** Bitwise operations *)
module Bitwise : sig
  val (~~~) : int -> int
  (** Bitwise logical negation. *)

  val (|||)  : int -> int -> int
  (** Bitwise logical or. *)

  val (&&&)  : int -> int -> int
  (** Bitwise logical and. *)

  val (^^^)  : int -> int -> int
  (** Bitwise logical exclusive or. *)

  val (<<<)  : int -> int -> int
  (** [n <<< m] shifts n to the left by m bits. The result is unspecified if m
      < 0 or m >= bitsize, where bitsize is 32 on a 32-bit platform and 64 on a
      64-bit platform. *)

  val (>>>) : int -> int -> int
  (** [n >>> m] shifts n to the right by m bits. This is an arithmetic shift:
      the sign bit of n is replicated. The result is unspecified if m < 0 or m
      >= bitsize. *)

  val (>>>!) : int -> int -> int
  (** [n >>>! m] shifts n to the right by m bits. This is a logical shift:
      zeroes are inserted regardless of the sign of n. The result is
      unspecified if m < 0 or m >= bitsize. *)
end


(** {2:fun Function Type and Operations} *)

val ( |> ) : 'a -> ('a -> 'b) -> 'b
(** [x |> f] reads as "apply forward" or "pipe" and similarly to [<|] is
    equivalent to [f x]. Can be used to create long chains of forward
    transformation in the style of Unix pipes:

{[
x |> f |> g |> h = h (g (f x))
]} *)

val identity : 'a -> 'a
(** [identity a] always returns [a]. This is called the identity function. *)

val flip : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
(** [flip f x y] is [f y x], i.e., the application of [f] with its first two
    arguments reversed.*)

val constantly : 'a -> 'b -> 'a
(** [constantly x y] is [x] for any input value [y]. *)

val curry : (('a * 'b) -> 'c) -> 'a -> 'b -> 'c
(* [curry f] converts an uncurried function [f] to a curried function. *)

val uncurry : ('a -> 'b -> 'c) -> ('a * 'b) -> 'c
(* [uncurry f] converts a curried function [f] to a function on pairs. *)

val compose : ('b -> 'c) -> ('a -> 'b) -> 'a -> 'c
(** [compose f g] is the mathematical composition of functions [f] and [g].
    [( << )] and [( >> )] are the infix versions of [compose].

{[
let compose f g = fun x -> f (g x)
]} *)

val ( << )  : ('b -> 'c) -> ('a -> 'b) -> 'a -> 'c
(** [f << g] is infix version of [compose f g]. *)

val ( >> )  : ('a -> 'b) -> ('b -> 'c) -> 'a -> 'c
(** [g >> f] is infix version of [compose f g]. *)


(** {2:pair Pair Type and Operations} *)

(* TODO Make this a module *)

type ('a, 'b) pair = 'a * 'b
(** A tuple with two values. *)

val first : ('a, 'b) pair -> 'a
(** [first pair] is the first elements of the [pair]

{[
assert (first (1, "x") = 1)
]} *)

val second : ('a, 'b) pair -> 'b
(** [second pair] is the second elements of the [pair]

{[
assert (second (1, "x") = "x")
]} *)


(** {2:option Option Type and Operations}

    Option represents an optional value: an [option] can be either [Some] and
    contain a value or a [None], and do not. *)

type nonrec 'a option = 'a option
(** The type of optional values ['a]. *)

val some : 'a -> 'a option
(** [some x] wraps [x] in a [Some] option value. *)

val none : 'a option
(** [none] is the [None] option value. *)

val is_some : 'a option -> bool
(** [is_some opt] is [true] if the option is a [Some] value. *)

val is_none : 'a option -> bool
(** [is_none opt] is [true] if the option is a [None] value. *)

val option : ('a -> 'b) -> 'b -> 'a option -> 'b
(** [case f default self] is [f] applied to the [Some] value of [self],
    or [default] if [self] is [None].

{[
assert (None    |> option ((+) 1) 0 = 0);
assert (Some 42 |> option ((+) 1) 0 = 43);
]} *)


(** {2:result Result Type and Operations} *)

type nonrec ('a, 'e) result = ('a, 'e) result
(** A result is either [Ok] meaning the computation succeeded, or it is an
    [Error] meaning that there was some failure. *)

val ok : 'a -> ('a, 'e) result
(** [ok x] creates an [Ok] result with value [x]. *)

val error : 'e -> ('a, 'e) result
(** [error x] creates an [Error] result with value [x]. *)

val is_ok : ('a, 'e) result -> bool
(** [is_ok res] is [true] if the result value is an [Ok]. *)

val is_error : ('a, 'e) result -> bool
(** [is_error res] is [true] if the result value is an [Error]. *)

val result : ('a -> 'b) -> ('e -> 'b) -> ('a, 'e) result -> 'b
(** A view function for the {!type:result} type.

    [result on_ok on_error res] is the function application [on_ok x] if [res]
    is [Ok x], or [on_error e] if [res] is [Error e].

    This function is equivalent to pattern-matching on the structure of the
    result value. For more information on [view] functions see the
    {!view_functions} section.

{[
let use_result =
  result Int.to_string (fun err -> "Error: " ^ err) in
assert (Ok 42 |> use_result = "42");
assert (Error "no value" |> use_result = "Error: no value")
]} *)


(** {2:public_exports Public Exports}

    This section exports public definitions from the defined modules aliasing
    some of the names. *)

val int : float -> int
(** Public alias for {!val:Int.of_float}. *)

val float : int -> float
(** Public alias for {!val:Float.of_int}. *)

val char : int -> char option
(** Public alias for {!Char.try_of_int}. *)

val code : char -> int
(** Public alias for {!Char.to_int}. *)

val not : bool -> bool
(** Public alias for {!Bool.not}. *)

val ( && ) : bool -> bool -> bool
(** Public alias for {!Bool.( && )}. *)

val ( || ) : bool -> bool -> bool
(** Public alias for {!Bool.( || )}. *)


